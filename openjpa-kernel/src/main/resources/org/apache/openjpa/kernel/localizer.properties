cant-convert-result: There is no conversion between query projection type \
	"{0}" and result type "{1}".
unloaded-detached: Attempt to access an unloaded field of detached instance \
	"{0}".
meta-unknownid: Cannot manipulate identity of type "{0}": it''s identity type \
	is unknown.
new-abstract: Cannot create an instance of "{0}": abstract classes and \
	interfaces are not yet supported.
bad-new-query: Attempt to construct a query from an extent or class.  You must \
	pass a (possibly null) query string or template to the query factory \
	method when creating the query. 
update-restrict: Detected attempt to modify field "{0}" with value strategy \
	"restrict".
reentrant-flush: Detected reentrant flush.  Make sure your flush-time instance \
	callback methods or event listeners do not invoke any operations that \
	require the in-progress flush to complete.
rolled-back: The transaction has been rolled back.  See the nested exceptions \
	for details on the errors that occurred.
bad-lock-level: This lock manager does not recognize lock level "{0}".
pessimistic-mutate: You are attempting to directly mutate a persistent second \
	class object (such as a collection or map field) that you obtained before \
	the transaction began.  After beginning a datastore transaction, you \
	must re-obtain any references to mutable second class objects from the \
	owning persistent object.  Detected attmpt to mutate value of field "{0}" \
	in instance "{1}".  This instance may not be locked correctly.
not-derefed: Encountered unknown dependent instance "{0}".  This error is \
	often caused by either removing a dependent instance from one dependent \
	field, but not other dependent fields that reference it, or by removing a \
	dependent instance from its owning field, flushing \
	(causing the unreferenced dependent instance to be deleted), and then \
	trying to assign the deleted instance to another field before commit.  \
	The instance cannot be un-deleted, resulting in an error.  Make sure not \
	to leave dangling dependent references to objects, and to reassign \
	dependent objects before flush so that OpenJPA does not think they are \
	unreferenced and therefore safe to delete.
init-null-pc: Attempt to initialize a state manager with a null \
	persistence-capable instance for type "{0}".  This is often caused by \
	attempting to load an instance of an abstract class, or \
	neglecting to use a class indicator when the base persistence-capable \
	class in an inheritance tree is abstract.
init-sm-pc: Attempt to initialize a state manager with an instance that is \
	already managed ("{0}").  You might be trying to persist this instance \
	in two threads at the same time.
bad-ds-oid: The type "{0}" declares datastore identity but the value \
	passed to lookup of type "{1}" is not a OpenJPA id instance.
null-oids: Some of the object ids passed to getObjectsById were null.
marked-rollback: The transaction cannot be committed, because it was already \
	marked for rollback only.  The transaction will be rolled back instead.
refresh-flushed: You cannot refresh an instance that has been flushed to the \
	data store.
pc-cast: Attempt to cast instance "{0}" to PersistenceCapable failed.  Ensure \
	that it has been enhanced.
del-instance: The instance of type "{0}" with oid "{1}" no longer exists in \
	the data store.  This may mean that you deleted the instance in a separate \
	transaction, but this context still has a cached version.
no-broker-class: The specified type "{0}" could not be loaded. Please ensure \
	that the class exists in the project class path.
bad-embed: Attempt to set an embedded value for unembeddable field "{0}". \
	Please report this error to OpenJPA support.
embed-ref: You are attempting to access an embedded object reference \
	that was obtained before the last transaction status change. After \
	transactions begin and end, all references to embedded objects become \
	invalid; you have to re-acquire the reference from the owning persistent \
	object.
deleted: Operation attempted on a deleted instance.
dirty: Illegal operation attempted on a dirty instance: dirty objects cannot \
	be evicted or made transient or non-transactional.
nested-exceps: This operation failed for some instances.  See the nested \
	exceptions array for details.
new: Illegal operation attempted on a newly persisted instance: new objects \
	cannot be evicted or made transient or non-transactional.
transient: Illegal operation attempted on a transient instance.
not-active: Can only perform operation while a transaction is active.
trans-active: The "{0}" transaction property cannot be set during an \
	active transaction.
active: This operation cannot be performed while a Transaction is active.
closed: The context has been closed.  The stack trace at which the \
	context was closed is held in the embedded exception.
closed-factory: The factory has been closed.  The stack trace at \
	which the factory was closed is held in the embedded exception.
non-trans-read: To perform reads on persistent data outside of a transaction, \
	the "NontransactionalRead" property must be set on the Transaction.
non-trans-write: To perform writes on persistent data outside of a \
	transaction, the "NontransactionalWrite" property must be set to true.
write-operation: To perform this operation, you must be withing a transaction, \
	or your settings must allow nontransactional writes and must not detach \
	all nontransactional reads.
not-managed: The given instance "{0}" is not managed by this context.
trans-not-managed: This broker is not configured to use managed transactions.
bad-detached-op: You cannot perform operation {0} on detached object "{1}". \
	This operation only applies to managed objects.
persist-detached: Attempt to persist detached object "{0}".
null-value: The field "{0}" of instance "{1}" contained a null value; \
	the metadata for this field specifies that nulls are illegal.
change-identity: Attempt to change a primary key field of an instance that \
	already has a final object id.  Only new, unflushed instances whose id you \
	have not retrieved can have their primary keys changed.
managed-oid: You cannot assign managed object "{0}" to the primary key field \
	of "{1}".  Embedded primary key values must be transient objects.
changed-oid: You have modified the object id field of "{2}".  Its old value \
	was "{0}", and its new value is "{1}".  Object id fields are immutable \
	once the object id of the instance has been assigned. 
cache-exists: An object of type "{0}" with oid "{1}" already exists in this \
	context; another cannot be persisted.
null-trans: Attempt to commit a null javax.transaction.Transaction.  Some \
	application servers set the transaction to null if a rollback occurs.
end-trans-error: An exception occurred while ending the transaction.  This \
	exception will be re-thrown.
not-bound: The file named "{0}" could not be found.
naming-exception: A NamingException was thrown while obtaining the \
	factory at "{0}" from JNDI.
attach-deleted: The object "{0}" with id "{1}" has been deleted and \
	cannot be attached.
not-detachable: The class "{0}" does not declare the "detachable" metadata \
	extension, so cannot be detached.
not-copyable: Attempt to copy field "{0}" failed.  The field is \
	not copyable.  This can occur with custom SCO types or with large result \
	set fields.  Only standard or immutable SCO types can be attached and \
	detached.
no-detach-object-id: Cannot access the detached object id of class "{0}". \
	Ensure that the class has the "detachable" metadata extension, and \
	the the class has been re-enhanced.
attach-version-del: Attempted to attach deleted instance type "{0}" with oid \
	"{1}".  If the instance is new, the version field should be left to its \
	default value.
attach-wrongclass: Attempted to attach instance "{0}" of type "{1}", but this \
	instance is already in the datastore as type "{2}".
sjvm-acquired-lock: Acquired an exclusive lock on oid "{0}": "{1}".
sjvm-released-lock: Released lock "{0}".
conn-not-supported: This data store cannot return connections.
incremental-flush-not-supported: This data store does not support incremental \
	flushing.  If you got this error while performing a query, make sure that \
	you have not set the FlushBeforeQueries option to true, either by \
	setting that option in your configuration file, or by programmatically \
	setting the current FetchConfiguration''s FlushBeforeQueries property \
	to QueryFlushModes.FLUSH_TRUE.
nontrans-read-not-supported: This data store does not support nontransactional \
	reads.  Set the NontransactionalRead property to false.
optimistic-not-supported: This datastore does not support optimistic \
	transactions.  Set the Optimistic property to false.
restore-unset: The RestoreValues option is off, so initial values are \
	not available. Turn on RestoreValues to be able to obtain initial \
	values.
mutable-restore-unset: The RestoreValues option is not set to "all", \
	initial values of mutable fields are not available. Set RestoreValues to \
	"all" in your properties to be able to obtain initial mutable values.
initial-unloaded: OpenJPA cannot provide the initial value for field "{0}" \
	because the field was never loaded before being changed.
dup-oid-assign: Attempt to assign id "{0}" to new instance "{1}" failed; \
	there is already an object in the L1 cache with this id. \
	You must delete this object (in a previous transaction or the current one) \
	before reusing its id.  This error can also occur when a horizontally \
	or vertically mapped classes uses auto-increment application identity and \
	does not use a hierarchy of application identity classes.
dup-load: Cannot load object with id "{0}".  Instance "{1}" with the same id \
	already exists in the L1 cache.  This can occur when you \
	assign an existing id to a new instance, and before flushing attempt to \
	load the existing instance for that id.
objectid-abstract: Cannot create new application identity instance for \
	abstract class "{0}".
bad-id-value: The given value "{0}" cannot be converted into an identity \
	for "{2}".  The value is the wrong type ({1}).
factory-init: Starting OpenJPA {0}
inverse-consistency: An inverse inconsistency in the object model was \
	detected while flushing the field "{0}" of the instance with id "{1}" \
	in context "{2}".
no-brokerfactory: You did not name the factory class with the required \
	property org.apache.openjpa.BrokerFactory.
brokerfactory-excep: There was an error when invoking the static \
	getInstance method on the named factory class "{0}".  See the \
	nested exception for details.
new-brokerfactory-excep: There was an error when invoking the static \
	newInstance method on the named factory class "{0}".  See the \
	nested exception for details.
bad-brokerfactory: Could not invoke the static getInstance method on the \
	named factory class "{0}".
bad-new-brokerfactory: Could not invoke the static newInstance method on the \
	named factory class "{0}".
bad-brokerfactory-class: The named BrokerFactory "{0}" is not valid.
instantiate-abstract: Cannot instantiate abstract class of type "{0}" with \
	object id "{1}"; this may indicate that the inheritance discriminator \
	for the class is not configured correctly.
nontrans-proxied: You cannot make a property access object created with "new" \
	nontransactional.
no-field: Field "{0}" is not declared in "{1}", or is not managed.
no-field-index: "{0}" is not the index of any managed field in "{1}".
cant-cascade-persist: Encountered unmanaged object "{0}" in persistent field \
	"{1}" of managed object "{2}" during flush.  However, this field does not \
	allow cascade persist.  You cannot flush unmanaged objects.
cant-cascade-attach: Encountered new object "{0}" in persistent field \
	"{1}" of managed object "{2}" during attach.  However, this field does not \
	allow cascade attach.  You cannot attach a reference to a new object \
	without cascading.
ref-to-deleted: Encountered deleted object "{0}" in persistent field \
	"{1}" of managed object "{2}" during flush.
no-version-field: Encountered object "{0}" without a version field during \
	attach.  In order to attach an object, it must either be enhanced or must \
	have a version field.
inmem-agg-proj-var: Queries with aggregates or projections using variables \
	currently cannot be executed in-memory.  Either set IgnoreCache to true, \
	set the org.apache.openjpa.FlushBeforeQueries property to true, or execute the query \
	before changing any instances in the transaction.  The offending query was \
	on type "{0}" with filter "{1}".
merged-order-with-result: This query on candidate type "{0}" with filter "{1}" \
	involves combining the results of multiple queries in memory. \
	You have chosen to order the results on "{2}", but you have not selected \
	this data in your setResult() clause.  Please include this ordering data \
	in setResult() so that OpenJPA can extract it for in-memory ordering.
query-nosupport: The "{0}" query type does not support this operation.
range-too-big: The range of the query is too big. Start index: "{0}", end \
	index: "{1}". The range must be less than Integer.MAX_VALUE.
invalid-range: The query range from {0} to {1} is not valid.
no-impls: Unable to execute a query on type "{0}".  This class or interface \
	is not mapped, and does not have any mapped implementors.
bad-param-name: The parameter name or position "{0}" passed to \
	execute() is not valid.  All map keys must be a declared parameter \
	name or a number matching the parameter position. 
force-in-mem: This query on type "{0}" must load the entire candidate class \
	extent and evaluate the query in-memory.  This may be very slow.  The \
	query must be executed in memory because OpenJPA is configured with \
	IgnoreCache=false and FlushBeforeQueries=false and \
	there are dirty instances that may affect the query''s outcome in the \
	cache.
cant-exec-inmem: Queries of this type ("{0}") cannot be executed in-memory. \
	Either set IgnoreCache to true, set the org.apache.openjpa.FlushBeforeQueries \
	property to true, or execute the query before changing any instances in \
	the transaction.
executing-query: Executing query: {0}
executing-query-with-params: Executing query: [{0}] with parameters: {1}
not-unique: The query on candidate type "{0}" with filter "{1}" was \
	configured to have a unique result, but more than one instance matched \
	the query.
serialized: Queries that have been serialized do not support this operation.
read-only: Attempt to modify a read-only query object.
no-class: A candidate Class must be specified before executing a query.
no-modify-resultclass: A query that declares a result class cannot be used \
	to perform bulk updates.
no-modify-unique: A query that declares unique results cannot be used \
	to perform bulk updates.
no-modify-range: A query that declares a result range cannot be used \
	to perform bulk updates.
unbound-param: Cannot execute query; the declared parameter "{0}" was \
	not given a value.
unbound-params: Cannot execute query; some declared parameters were not given \
	values.  You must supply a value for each of the following parameters, \
	in the given order: {0}
extra-params: More parameters were passed to execute() than were declared: \
	{1} parameters were specified for query execution, but only {0} \
	parameters were declared in the query.
null-primitive-param: Parameter "{0}" was declared with a primtive type, but \
	has been given a null value.
merged-aggregate: This query on candidate type "{0}" with filter "{1}" \
	involves combining the results of multiple sub-queries.  However, because \
	this query is for aggregate data, OpenJPA cannot combine the sub-query \
	aggregates into correct final values.
bad-dec: The {1} declaration "{0}" is \
	not valid. Variables and imports must be delimited with ";".  Parameters \
	and orderings must be delimited with ",".  Imports require the "import" \
	keyword, and orderings require the "ascending" or "descending" keyword.
mod-bigdecimal: You cannot use the modulo operator (%) on numbers of type \
	BigDecimal.
cant-convert: Cannot convert object "{0}" of type "{1}" into an instance of \
	"{2}".
bad-method-class: You set the method name of this org.apache.openjpa.MethodQL query to \
	"{1}", but class "{0}" is not a valid class name.  Make sure to fully \
	qualify the class name or to import its package into this query if the \
	class is not in the query candidate class'' package. 
method-not-static: Method "{0}" named in the org.apache.openjpa.MethodQL query must be static.
no-method: You must set the query filter to the name of the method to execute \
	for this org.apache.openjpa.MethodQL query instance.
method-error: There was an error invoking method "{0}" with arguments "{1}".
bad-param-type: The type "{0}" as used in the parameter declarations \
	could not be found in the imports.
cant-set: Result type "{0}" does not have any public fields or setter methods \
	for the projection or aggregate result element "{1}", nor does it have a \
	generic put(Object,Object) method that can be used, nor does it have a \
	public constructor that takes the types {2}.
pack-err: There was an error packing the projection and/or aggregate results \
	of the query into result type "{0}".  See the nested throwable for details.
pack-instantiation-err: There was an error creating an instance of type "{0}" \
	when packing the projection and/or aggregate results of the query. Ensure \
	that you have defined a public no-args constructor in "{0}".
bad-inmem-method: Method "{0}(StoreContext, ClassMetaData, boolean, Object, \
	Map, FetchConfiguration)" is not declared in type "{1}". \
	Check the method name supplied in your org.apache.openjpa.MethodQL query filter.  \
	OpenJPA is attempting to execute this query in-memory; if you implemented the \
	datastore method instead (a method with the same signature but without the \
	Object argument) and want this query to execute in the datastore, either \
	make the query before modifying objects in the current transaction, \
	set IgnoreCache to true, or set the org.apache.openjpa.FlushBeforeQueries property to \
	true.
bad-datastore-method: Method "{0}(StoreContext, ClassMetaData, boolean, Map, \
	FetchConfiguration)" is not declared in type "{1}".  Check \
	the method name supplied in your org.apache.openjpa.MethodQL query filter.  OpenJPA is \
	attempting to execute this query against the datastore; if you implemented \
	the in-memory method instead (a method with the same signature but with an \
	Object argument) and want this query to execute in-memory, supplly a \
	Collection of candidates to filter.
only-update-primitives: Bulk update queries when executed in memory \
	may only change the value of primitives and simple Object fields.
no-savepoint-copy: Unable to copy field "{0}" for savepoint.
savepoint-exists: A savepoint with the name "{0}" already exists.  \
	Each savepoint name must be unique.
no-lastsavepoint: Cannot rollback/release last savepoint as no savepoint \
	has been set.
no-savepoint: You have not set a savepoint with the name "{0}"
savepoint-init: This savepoint has already been initialized.
savepoint-flush-not-supported: The configured SavepointManager does not \
	support incremental flushing when a savepoint has been set.  You must \
	release your savepoints before flushing.
callback-err: An error occured processing callbacks for instance of type "{0}".
bad-agg-listener-hint: Query hint value "{0}" ({1}) cannot be converted into \
	an aggregate listener.
bad-filter-listener-hint: Query hint value "{0}" ({1}) cannot be converted \
	into a filter listener.
bad-getter-hint: Invoking the getter for hint key "{0}" on "{1}" caused \
	an error.
bad-setter-hint: Invoking the setter for hint key "{0}" on "{1}" with \
	value "{2}" caused an error.
detach-val-mismatch: The instance "{0}" is managed by another context and \
	cannot be inspected for field values.
detach-val-badsm: The instance "{0}" has an unknown state manager which \
	prevents field inspection.
null-oid: Cannot perform find using null object id.
illegal-op-in-prestore: This operation is illegal when called during \
	transaction completion.
no-expressions: The query cannot be executed because it has no \
	valid expressions.
null-fg: Attempt to add null/empty fetch group name to fetch configuration.
null-field: Attempt to add null/empty field name to fetch configuration.
